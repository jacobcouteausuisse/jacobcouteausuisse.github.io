---
layout: post
title:  "potency : automatic trading using RSI indicator"
categories: 
    - asteroidlabs
---
I very much like the RSI indicator for swing trading. It provides and easy way to understand the current market trend, and can be easily interpreted by a program since it's only a single number.

This project is going to be build using NodeJS and Docker, for portability between my MacBook, RaspberryPi and Vultr instance. Naming is project is always a weird process. This time the protorype will carry the name *potency*, because it is very potent. Do you see how funny I am? I thought so.

## goals
Basicaly, I want to program to gather data about markets and store it in a database, to keep a history. On demand, it will calculate the pairs' RSI from the (local) historic data, and send it to me using Telegram. Eventualy, if it bahaves well, I want the trading to be automated.

## warmup
As with all exercices, we need some warmup first. In this case, we will query the last 20 (14 is the real minimum) candles from Binance, with which we can calculate the RSI.
Using [zoeyg's binance](https://github.com/zoeyg/binance) module, I can easily query market data from binance using :
{% highlight javascript %}
binanceRest.klines({
    symbol: symbol,
    interval: interval,
    limit: '100' 
})
.then((data) => {
    console.log(data);
})
.catch((err) => {
    console.error(err);
});
{% endhighlight %}
The resulting data cointains a bunch of information on the specific candle, and we'll store it in a MongoDB instance using the appropriate Schema.
Now, because I want to query a list of pairs, I wrap it up in a function and call it inside a forEach() loop. For the sake of your hair, watch out for NodeJS asychronocity.
The process will not exit if mongoose still has a connection idle, so we need to manage that. I used a decreasing counter in the mongo.save() loop so that if there's no more data to be saved, it will kill the connection.

## feed
Binance has a very robust API and offers a WebSocket stream that we can connect to and receive *pushed* data. Using the same module, we can easily subscribe to a ticker's candles stream :
{% highlight javascript %}
binanceWS.onKline(symbol, interval, (data) => {
    if (data.kline.final == true){ // save only full candles
    var symbol = new Pair({eventType: data.eventType, eventTime: data.eventTime, symbol: data.symbol, interval: interval, currentClose: data.kline.close});
        symbol.save(function (err) {
            if (err) {
                console.log(err);
            }else {
                console.log('Added ' + data.symbol + ' with timestamp '+ data.eventTime + ' interval of '+ interval + ' to DB');
            }
        });  
    }else{} // skip the pushed update
});
{% endhighlight %}
Now, Binance's stream will push updates every second, but I only want to save updates when the candle is closed, so I test if the kline is final. One day, I would like to implement a type of "last-tick-update" to get more precise RSI calculations using the latest data, and the next 14 intervals, instead of using only last 14 interval.

## bot
During the programming of the other two parts, I decided to make a Telegram bot, where I could send query and it would reply with the current RSI for entry and exit, on different intervals. For a simple bot, I use [yagop's node-telegram-bot-api](https://github.com/yagop/node-telegram-bot-api) module. It's very easy to get started, for example with the keyword "/echo":
{% highlight javascript %}
bot.onText(/\/echo (.+)/, (msg, match) => {
  // 'msg' is the received Message from Telegram
  // 'match' is the result of executing the regexp above on the text content
  // of the message

  const chatId = msg.chat.id; // User ID
  const resp = match[1]; // the captured "whatever"

  // send back the matched "whatever" to the chat
  bot.sendMessage(chatId, resp);
});
{% endhighlight %}
With this, I can use a keyword with multiple options to craft a very specific query. For example, using "/check buy 30m", the bot will reply with every pairs that have a RSI below 35 on the 30m interval. Pretty neat!

## dockerfile(s)
First off, lets start with a fresh and current Node image :
{% highlight docker %}
FROM node:10.12

RUN apt-get update

ADD / /opt/potency
WORKDIR /opt/potency

RUN npm install
RUN npm update
{% endhighlight %}
It is a very simple dockerfile, it only copies the documents to the image, then install all the npm modules. The docker file is the same for `warmup`, `feed` and `bot`. I know that I could combine everything under one container, but I'm not used to that and was a bit rushed so it was faster to use 3 containers.

## docker-compose
Remember when I used MongoDB? Yeah, we need a mongo container too!
This simple docker-compose file will build and start every containers in this order : `mongo`, `warmup`, `feed` and `bot`.
{% highlight docker %}
version: "3"
services:
  warmup:
    build: ./warmup/
    command: node index.js
    depends_on:
      - mongo
  feed:
    build: ./feed/
    command: node index.js
    depends_on:
      - warmup
  bot:
    build: ./bot/
    command: node index.js
    depends_on:
      - feed
  mongo:
    image: mongo
    container_name: mongo
    environment:
      - discovery.type=single-node
    ports:
      - 27017:27017
{% endhighlight %}
In only one command, I can start the whole project from any computer/server I have, and scale it easily.
Let's see how successful my trades are with this!